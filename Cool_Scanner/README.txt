README file for Programming Assignment 2 (Java edition)
=======================================================

Your directory should now contain the following files:

 Makefile
 README
 cool.lex
 test.cl
 AbstractSymbol.java  -> [course dir]/src/PA2J/AbstractSymbol.java
 BoolConst.java       -> [course dir]/src/PA2J/BoolConst.java
 Flags.java           -> [course dir]/src/PA2J/Flags.java
 IdSymbol.java        -> [course dir]/src/PA2J/IdSymbol.java
 IdTable.java         -> [course dir]/src/PA2J/IdTable.java
 IntSymbol.java       -> [course dir]/src/PA2J/IntSymbol.java
 IntTable.java        -> [course dir]/src/PA2J/IntTable.java
 Lexer.java           -> [course dir]/src/PA2J/Lexer.java
 AbstractTable.java   -> [course dir]/src/PA2J/AbstractTable.java
 StringSymbol.java    -> [course dir]/src/PA2J/StringSymbol.java
 StringTable.java     -> [course dir]/src/PA2J/StringTable.java
 Utilities.java       -> [course dir]/src/PA2J/Utilities.java
 TokenConstants.java  -> [course dir]/src/PA2J/TokenConstants.java
 *.java		      other generated files

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	cool.lex is a skeleton file for the specification of the
	lexical analyzer. You should complete it with your regular
	expressions, patterns and actions. 

	test.cl is a COOL program that you can test the lexical
	analyzer on. It contains some errors, so it won't compile with
	coolc. However, test.cl does not exercise all lexical
	constructs of COOL and part of your assignment is to rewrite
	test.cl with a complete set of tests for your lexical analyzer.

	TokenConstants.java contains constant definitions that are used by
	almost all parts of the compiler. DO NOT MODIFY.

	*Table.java and *Symbol.java contain string table data
	structures.  DO NOT MODIFY.

	Utilities.java contains various support functions used by the
	main lexer driver (Lexer.java).  DO NOT MODIFY.

	Lexer.java contains the main method which will call your lexer
	and print out the tokens that it returns.  DO NOT MODIFY.

        CoolLexer.java is the scanner generated by jlex from cool.lex.
        DO NOT MODIFY IT, as your changes will be overritten the next
        time you run jlex.

	mycoolc is a shell script that glues together the phases of the
	compiler using Unix pipes instead of statically linking code.  
	While inefficient, this architecture makes it easy to mix and match
	the components you write with those of the course compiler.
	DO NOT MODIFY.	

Instructions
------------

	To compile your lextest program type:

	% make lexer

	Run your lexer by putting your test input in a file 'foo.cl' and
	run the lextest program:

	% lexer foo.cl

	To run your lexer on the file test.cl type:

	% make dotest

	If you think your lexical analyzer is correct and behaves like
	the one we wrote, you can actually try 'mycoolc' and see whether
	it runs and produces correct code for any examples.
	If your lexical analyzer behaves in an
	unexpected manner, you may get errors anywhere, i.e. during
	parsing, during semantic analysis, during code generation or 
	only when you run the produced code on spim. So beware.


        Instructions for turning in the assignment will be posted on the
        course web page.

        GOOD LUCK!
        
  
SUMMARY OF DESIGN
------------------

	In this assignment I have worked over the initial component of the compiler,
	lexical analaysis. Written a lexical analyzer, also called a scanner, using
	a lexical analyzer generator jlex.
	Basically, I have made modifications among two of the skeleton files provided 
	by Professor, namely cool.lex and test.cl containing the actual working and
	test case being evaluated correctly by my scanner respectively.
	
  	cool.lex
  	--------
  	
  	In this firstly no change have been made by me in the user code which is copied 
  	verbatim to the lexer class definition.
  	
  	Folowing regular expressions have been explicitly defined for set of tokens for 
  	COOL in appropriate formate, taking help from the COOL mannual.
  	
  	CLASS = [cC][lL][aA][sS][sS]
	ELSE = [eE][lL][sS][eE]
	FALSE = [f][aA][lL][sS][eE]
	FI =    [fF][iI]
	IF =    [iI][fF]
	IN =    [iI][nN]
	INHERITS = [iI][nN][hH][eE][rR][iI][tT][sS]
	ISVOID =    [iI][sS][vV][oO][iI][dD]
	LET = [lL][eE][tT]
	LOOP = [lL][oO][oO][pP]
	 POOL = [pP][oO][oO][lL]
	THEN = [tT][hH][eE][nN]
	WHILE = [wW][hH][iI][lL][eE]
	CASE = [cC][aA][sS][eE]
	ESAC = [eE][sS][aA][cC]
	NEW = [nN][eE][wW]
	OF = [oO][fF]
	NOT = [nN][oO][tT]
	TRUE = [t][rR][uU][eE]
	LETTER = [a-zA-Z]
	DIGIT = [0-9]

  	In the enclosing block of %eofval{ //// %eofval} describes what actions need to be 
  	at the EOF file depending on the yy_lexical_state as follows:
  	
  	* if the state is YYINITIAL, no action to be performed.
  	* if the state is COMMENT, returns an error with message "EOF in comment" and,
  	* if the state is COMMENTDASH, nothing to perform.
  	* if the state is STRING, returns an error with message "EOF in string constant".
  	
  	Atlast, the important part which defines the actual funationality to be performed by
  	regular expression defined above and operators, colon, etc.
  	
  	
  	
  	test.cl
  	-------
  	
  	I have tried my best to cover all the exhaustive test cases that needed to be addressed
  	from test.cl. such as:
  	
  	* String containing an unescaped newline, report an error as 
  	"Unterminated string constant" and if string is too long, an error "String constant too
  	long" is reported and if string conatins null charcter, an error "String has null character"
  	is reported.
  	
  	* Comment starting with -- terminated only when EOF or nextline is encountered.
  	
  	* Comment starting with (* but not terminated by *).
  	
  	* Nested comment cases also had been covered.
  	
  	Thus, Scanner also has been evaluated by comparing the output produced by my lexer and PA2J
  	lexer with no difference encountered. Concluding, it to be correctly identifying all the token 
  	and even throwing error message on unrecognised token, continuing with further scanning without 
  	halting in between till the EOF.


  
  
  
  
  
  
  
  
  
  
  